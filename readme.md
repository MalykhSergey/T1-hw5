# Домашнее задание №5 ИТ-лагеря Т1

**Задание:** Токен содержит чувствительную информацию и передается по незащищенному каналу.
Необходимо обеспечить защиту информации как от компрометации, так и от подмены, в том
числе участниками обмена.

## Запуск

```shell
mvn test
```

## Перед описанием решения

Описание задачи *допускает достаточно широкую трактовку.* Поэтому, чтобы получить удовлетворяющее решение, сведём задачу к более общему случаю.

**Общее описание задачи:** Алиса и Боб (и другие участники) обмениваются сообщениями по незащищённому каналу связи.
Необходимо обеспечить защиту информации как от компрометации, так и от подмены её шпионом.

Таким образом, для решения задачи требуется обеспечить несколько условий.

1. Необходимо иметь возможность проверить, что сообщение действительно отправлено Алисой или Бобом.
Шпион может попытаться притвориться Алисой или Бобом, что необходимо предотвратить.

2. Сообщение может прочитать только его получатель. Если шпион перехватит сообщения, то он не должен иметь возможности прочитать или изменить его.

3. Из сообщения необходимо понять, кто его отправитель.

Эти условия запрещают обмениваться Алисе или Бобу какими либо секретными ключами по незащищённому каналу связи.
Ведь шпион может перехватить ключи и получить возможность читать и подделывать сообщения.

Решив эту задачу, будет автоматически решена и исходная задача, как частный случай этой.

## Описание решения

В качестве возможного варианта решения задачи предлагаю следующий вариант.
1. Алиса, Боб и все участники обмена создают пару ключей: приватный и публичный.
2. Они в **обход незащищённого канала** (например, приходят лично) регистрируются в Центре сертификации.
3. Центр сертификации на каждого участника создаёт сертификат, подписывая его своим ключом. Таким образом,
участники общения при необходимости смогут запрашивать сертификат собеседника и проверять, что он выдан центром сертификации.
4. Затем Алиса подписывает своё сообщение.
5. Алиса создаёт случайный сеансовый *симметричный* ключ (оптимизация производительности).
6. Алиса шифрует сообщение с помощью сессионого ключа.
7. Алиса шифрует сеансовый ключ с помощью публичного ключа Боба, который был получен из публичного сертификата.
8. Алиса отправляет: шифрованное сеансовым ключом сообщение и шифрованный публичным ключом Боба сеансовый ключ.
К сообщению Алиса прикладывает свой сертификат, чтобы сообщить, что сообщение её, и чтобы передать вместе публичный ключ. 
9. Боб выполняет операции по дешифровке и валидации подписи в обратном порядке.

Подобная схема решает поставленную задачу следующим образом.

С одной стороны, Алиса отправляя сообщение Бобу может быть уверена, что прочесть его сможет лишь Боб, ведь только у него есть приватный ключ для расшифровки.

С другой стороны, Боб может быть уверен, что сообщение написала Алиса, так оно подписано ею.

Также из-за использования сертификатов шпион не может притвориться Бобом или Алисой, так как он не сможет подделать подпись центра сертификации.

Более того, схема общения динамически масштабируемая. После регистрации в центре сертификации, все участники могут общаться между собой,
при необходимости получая сертификаты собеседников прямо по незащищённому каналу связи.

Единственная слабость - необходимость защищённого канала для регистрации в центре сертификации.

Сами по себе сертификаты имеют несколько преимуществ. С их помощью можно получить дополнительную информацию, например срок действия, отозван ли он,
что повышает гибкость системы безопасности.

Единственная пакость которую может совершить шпион: продублировать сообщение Алисы Бобу. Однако этого можно избежать протоколом более высокого уровня, например,
указывая в подписанной части номер сообщения.

## Описание реализации

 В реализованной системе создание засекреченного сообщения происходит в конструкторе CipherMessage.
 ```java
public class CipherMessage implements SecuredMessage {
    public CipherMessage(Certificate senderCertificate, PublicKey receiverKey, byte[] data, byte[] sign, String signAlg, String keyGenAlg, String asymmetricAlg, String symmetricAlg) {
        this.signAlg = signAlg;
        this.keyGenAlg = keyGenAlg;
        this.asymmetricAlg = asymmetricAlg;
        this.symmetricAlg = symmetricAlg;
        this.certificate = senderCertificate;
        try {
            this.sign = sign;
            SecretKey sessionKey = KeyGenerator.getInstance(keyGenAlg).generateKey();
            this.encryptedData = encryptData(sessionKey, data);
            this.encryptedSessionKey = encryptSessionKey(sessionKey, receiverKey);
        } catch (Exception e) {
            throw new RuntimeException(e.getMessage());
        }
    }
//    ...
}
 ```

Стоит заметить, что в целях безопасности **Пользователь самостоятельно подписывает передаваемые данные**, никому не передавая свои секретные ключи.
CipherMessage же шифрует сообщение для получателя его публичным ключом. **После создания CipherMessage исходные данные сможет прочитать только получатель!**.
CipherMessage инкапсулирует в себе логику по шифровке/дешифровке сообщения, предоставляя пользователям простой и понятный интерфейс.


```java
public class CryptoUser implements User {
//    ...
@Override
public SecuredMessage sendSecuredMessage(PublicKey receiverKey, byte[] data) {
        return new CipherMessage(certificate, receiverKey, data, signatureManager.sign(data), SIGN_ALG, KEY_GEN_ALG, ASYMMETRIC_ALG, SYMMETRIC_ALG);
}
}
```

CryptoUser никому не доверяет, поэтому он сам проверяет подпись тела сообщения.
В данной реализации, пользователь при каждом обращении проверяет полученный сертификат
в центре сертификации. В реальности возможно сохранение собственного реестра сертификатов и сверка по нему.
Сертификационному центру нет необходимости шифровать сообщение при ответе о проверке сертификата.

```java
public class CryptoUser implements User {
    //    ...
    @Override
    public void receiveMessage(SecuredMessage securedMessage) {
        // Имитируем запрос проверки подлинности сертификата по незащищённому каналу
        // Центр сертификации отвечает в формате подписанных сообщений (информация несекретная)
        // Изменить ответ сервера невозможно, иначе подпись станет не валидна
        Instant start = Instant.now();
        SignedMessage<VerifyResponse> signedMessage = certificationCenter.secureVerifyCertificate(securedMessage.getCertificate());
        if (!signatureManager.verify(signedMessage.getBytes(), signedMessage.getSign(), generalCertificate.getPublicKey())) {
            throw new SecurityException("Invalid Sign in VerifyResponse");
        }
        VerifyResponse verifyResponse = signedMessage.getMessage();
        if (!verifyResponse.getCertificate().equals(certificate)) {
            throw new SecurityException("Different certificate in VerifyResponse");
        }
        if (!verifyResponse.isValid()) {
            throw new SecurityException("Invalid Certificate in message");
        }
        // Если кто-решить подсунуть устаревший ответ сервера
        if (verifyResponse.getCreated().isBefore(start)) {
            throw new SecurityException("Invalid response created time");
        }
        byte[] decrypted = securedMessage.decrypt(keyPair.getPrivate());
        if (!signatureManager.verify(decrypted, securedMessage.getSign(), securedMessage.getCertificate().getPublicKey())) {
            throw new SecurityException("Invalid Sign in Message");
        }

        System.out.printf("\n %s received message from %s: %s \n", name, securedMessage.getCertificate().getSubjectName(), new String(decrypted));
    }
}
```
Чтобы избежать подмены ответа сертификационного центра шпионом, каждый ответ содержит
исчерпывающую информации о проверке: результат, сертификат, время проверки, цифровую подпись. 

Для построения согласованной системы, где все участники используют схожие алгоритмы, создан класс CryptoFactory, 
который позволяет создать всё необходимое для демонстрации работы системы.

В работе использованы следующие алгоритмы доступные в JDK 21:

```java
public class CryptoFactoryImpl implements CryptoFactory {

    public static final String SIGN_ALG = "RSASSA-PSS";
    public static final String ASYMMETRIC_ALG = "RSA/ECB/OAEPWithSHA-256AndMGF1Padding";
    public static final String SYMMETRIC_ALG = "AES/CBC/PKCS5Padding";
    // ...
}
```

Демонстрация работы системы, а также неудачных попыток шпиона помешать приватной переписке Алисы и Боба приведена в юнит-тестах.

### Примечание
Класс CryptoUser может достаточно просто адаптирован в CryptoTransmitter и использоваться для безопасного общения по сети.
Однако в рамках задачи, это будет уже избыточно.